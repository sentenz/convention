# Cross Compiler

A cross compiler is a compiler capable of creating executable code for a platform other than the one on which the compiler is running. For example, a compiler that runs on a PC but generates code that runs on Android smartphone is a cross compiler.

- [Naming Convention](#naming-convention)
- [Glossary](#glossary)
- [See also](#see-also)

## Naming Convention

The naming rule of the cross-compilation toolchain is: `[arch]-[vendor]-[os]-[abi]`.

- `arch`
  > Refers to target architecture: arm, mips, x86, i686.

- `vendor`
  > Refers to toolchain supplier: apple.

- `os`
  > Refers to the target operating system: darwin, linux, none (bare metal systems).

- `eabi`
  > Refers to Embedded Application Binary Interface: eabi, gnueabi, gnueabihf.

Illustrations as follows:

- arm-none-eabi

  This tool chain targets for ARM architecture (including ARM Linux boot and kernel), has no vendor (generic), does not target an operating system and complies with the ARM EABI.
  
  Generally suitable for ARM7, Cortex-M and Cortex-R core chips.

- arm-none-linux-gnueabi, arm-linux-gnueabi

  This toolchain targets the ARM architecture, has no vendor (generic), creates binaries that run on the Linux operating system, and uses the GNU EABI. It is used to target ARM-based Linux systems.

  Used for Linux systems based on ARM architecture, and can be used to compile u-boot, Linux kernel, linux applications of ARM architecture, etc. arm-none-linux-gnueabi is based on GCC, uses the Glibc library, and is a compiler optimized. Generally, ARM9, ARM11, Cortex-A kernels and Linux operating system.

- i686-apple-darwin10-gcc-4.2.1

  This toolchain targets the Intel i686 architecture, the vendor is Apple, and the target OS is Darwin version 10 with the  of GCC version 4.2.1.

- arm-ostl-linux-gnueabi

  This toolchain targets the ARM architecture, the vendor is STMicroelectronics for OpenSTLinux in STM32MP, creates binaries that run on the Linux operating system, and uses the GNU EABI. It is used to target ARM-based Linux systems.

- arm-eabi

  Android  ARM compiler.

- arm-linux-gnueabi-gcc and arm-linux-gnueabihf-gcc

  The two cross-compilers are applicable to two different architectures of armel and armhf. The two architectures of armel and armhf adopt different strategies for floating-point operations (arms with fpu can support these two floating-point operations strategies).

  In fact, these two cross-compilers are just different default values ​​of the gcc option -mfloat-abi. The gcc option -mfloat-abi has three values, soft, softfp, and hard (the latter two of which require the fpu floating point unit in the arm, soft and the latter two are compatible, but the two modes of softfp and hard are not compatible with each other ): soft: FPU is not used for floating point calculation, even if there is an FPU floating point unit, it is not used, but the software mode is used.

  softfp: The default value adopted by the armel architecture (corresponding compiler is arm-linux-gnueabi-gcc) is calculated by fpu, but the parameters are passed by ordinary registers, so that when interrupting, only ordinary registers need to be saved, and the interrupt load is small. But the parameters need to be converted to floating point and then calculated.

  hard: The default value adopted by the armhf architecture (corresponding compiler arm-linux-gnueabihf-gcc) is calculated by fpu, and the parameters are also passed by the floating-point register in the fpu, eliminating the need for conversion. The performance is the best, but the interrupt load high.

## Glossary

Definitions of terms.

- ABI
  > Application Binary Interface (ABI) for the ARM Architecture. In the computer, the application binary interface describes the low-level interface between the application (or other types) and the operating system or other applications.

- EABI
  > Embedded Application Binary Interface (EABI). The embedded application binary interface specifies the file format, data type, register usage, stack organization optimization, and standard conventions of parameters in an embedded software. Developers using their own assembly language can also use EABI as an interface with the assembly language generated by a compatible compiler. The main difference with ABI is that ABI is used on the computer and EABI is used on the embedded platform (e.g. ARM, MIPS).

- amd64
  > AMD64 is AMD’s 64-bit extension of Intel’s x86 architecture, and is also referred to as x86_64 (or x86-64).

- arm64
  > ARM64 is the 64-bit extension of the ARM CPU architecture.

- x86_64
  > x86_64 (or x86-64) refers to a 64-bit instruction set invented by AMD as an extension of Intel’s x86 architecture. AMD calls its x86_64 architecture, AMD64, and Intel calls its implementation, Intel 64.

## See also

- Actorsfit [arm cross compiler](https://blog.actorsfit.com/a?ID=01700-1ce8edc2-d16c-4135-9abc-fd37ff641c25) article.
